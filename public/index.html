<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ç”¨æˆ·é…ç½®ç®¡ç†</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      padding: 20px;
      background: #f5f7fa;
      color: #333;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
    }

    .form-group {
      margin-bottom: 16px;
    }

    label {
      display: block;
      margin-bottom: 6px;
      font-weight: bold;
    }

    input[type="text"],
    textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-family: monospace;
    }

    button {
      padding: 8px 16px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    button:hover {
      opacity: 0.9;
    }

    button.secondary {
      background: #6c757d;
    }

    .status {
      padding: 10px;
      margin: 10px 0;
      border-radius: 4px;
    }

    .status.error {
      background: #f8d7da;
      color: #721c24;
    }

    .status.success {
      background: #d4edda;
      color: #155724;
    }

    /* å­—æ®µç¼–è¾‘å™¨æ ·å¼ */
    .fields-container {
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 10px;
      background: #fff;
      max-height: 500px;
      overflow-y: auto;
    }

    .field-item {
      padding: 8px;
      margin: 6px 0;
      background: #f9f9f9;
      border-radius: 4px;
      position: relative;
    }

    .field-header {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
    }

    .field-type-badge {
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 3px;
      color: white;
      background: #3498db;
    }

    .field-type-badge.string {
      background: #2ecc71;
    }

    .field-type-badge.number {
      background: #e67e22;
    }

    .field-type-badge.boolean {
      background: #9b59b6;
    }

    .field-type-badge.array {
      background: #e74c3c;
    }

    .field-type-badge.object {
      background: #1abc9c;
    }

    .field-actions {
      margin-left: auto;
      font-weight: bold;
      cursor: pointer;
    }

    .field-actions .delete-btn {
      color: red;
    }

    .field-edit-form {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px dashed #ccc;
      display: none;
    }

    .field-edit-form input,
    .field-edit-form select,
    .field-edit-form textarea {
      width: 100%;
      padding: 4px;
      margin: 4px 0;
      font-family: monospace;
    }

    .hero-list {
      margin-top: 8px;
    }

    .hero-list button {
      background: #2ecc71;
      padding: 4px 8px;
      margin: 2px;
      font-size: 12px;
    }

    .sub-fields-container {
      margin-top: 8px;
      padding-left: 16px;
      border-left: 2px solid #ddd;
    }

    .hidden {
      display: none !important;
    }

    /* ç”¨æˆ·å¡ç‰‡æ ·å¼ï¼šå¸¦åœ†è§’èƒŒæ™¯åº• */
    .user-card {
      background: white;
      border-radius: 12px;
      padding: 12px 16px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
      border: 1px solid #eaeaea;
    }

    /* ç»Ÿä¸€æ“ä½œæŒ‰é’®å®¹å™¨ */
    .action-buttons {
      display: flex;
      gap: 6px;
      margin-left: auto;
      /* æ¨åˆ°æœ€å³è¾¹ */
      flex-shrink: 0;
    }

    /* å¡ç‰‡å†…éƒ¨ä½¿ç”¨ flex å¸ƒå±€ */
    .user-card,
    .transaction-card {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
    }

    .tab-buttons {
      margin-bottom: 16px;
    }

    .tab-buttons button {
      margin-right: 8px;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .transaction-card {
      background: #fff8e1;
      border-left: 4px solid #ffc107;
      padding: 12px;
      margin-bottom: 12px;
      border-radius: 8px;
    }

    .hash-match {
      color: green;
      font-weight: bold;
    }

    .hash-mismatch {
      color: red;
      font-weight: bold;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>ğŸ” ç”¨æˆ·é…ç½®ç®¡ç†</h1>

    <!-- Tabs -->
    <div class="tab-buttons">
      <button onclick="switchTab('users')">ğŸ‘¤ ç”¨æˆ·ç®¡ç†</button>
      <button onclick="switchTab('transactions')">ğŸ“¬ å¾…å®¡æ ¸äº‹åŠ¡</button>
    </div>

    <!-- ç”¨æˆ·ç®¡ç† Tab -->
    <div id="tab-users" class="tab-content active">
      <div class="form-group">
        <button type="button" onclick="createNewUser()" style="background:#2ecc71;">â• åˆ›å»ºæ–°ç”¨æˆ·</button>
      </div>
      <div id="userList" class="form-group">
        <p>æ­£åœ¨åŠ è½½...</p>
      </div>
      <div id="userForm" class="hidden">
        <!-- åŸæœ‰è¡¨å•å†…å®¹ -->
        <div class="form-group">
          <label>å½“å‰ç¼–è¾‘ç”¨æˆ·ï¼š<span id="editingUsernameDisplay"></span></label>
        </div>
        <div class="form-group">
          <label>ç”¨æˆ·å±æ€§ï¼ˆæ”¯æŒåµŒå¥—å¯¹è±¡ä¸æ•°ç»„ï¼‰ï¼š</label>
          <div id="userFieldsContainer" class="fields-container"></div>
          <button type="button" onclick="addUserField(null)" style="margin-top:10px;">â• æ·»åŠ æ ¹å­—æ®µ</button>
        </div>
        <div class="form-group">
          <button type="button" onclick="togglePasswordSection()" style="background:#e67e22; font-size:14px;">
            ğŸ”‘ é‡è®¾å¯†ç 
          </button>
        </div>
        <div id="passwordSection" class="form-group hidden">
          <label for="passwordInput">æ–°å¯†ç ï¼ˆç•™ç©ºåˆ™ä¸ä¿®æ”¹ï¼‰ï¼š</label>
          <input type="password" id="passwordInput" placeholder="è¾“å…¥æ–°å¯†ç " />
        </div>
        <button type="button" onclick="saveUser()">ğŸ’¾ ä¿å­˜é…ç½®</button>
        <button type="button" onclick="cancelEdit()" style="background:#6c757d; margin-left:8px;">â¬…ï¸ è¿”å›åˆ—è¡¨</button>
      </div>
    </div>

    <!-- äº‹åŠ¡å®¡æ ¸ Tab -->
    <div id="tab-transactions" class="tab-content">

      <h2>ğŸ“¬ å¾…å®¡æ ¸äº‹åŠ¡</h2>
      <div id="transactionList">
        <p>æ­£åœ¨åŠ è½½...</p>
      </div>
      <div id="privateKeySection" class="form-group">
        <label for="privateKeyInput">ğŸ”‘ å®¡æ ¸ç”¨ç§é’¥ï¼ˆPEM æ ¼å¼ï¼‰ï¼š</label>
        <textarea id="privateKeyInput" rows="5" placeholder="-----BEGIN PRIVATE KEY-----..."></textarea>
        <div style="margin-top: 6px;">
          <button type="button" onclick="savePrivateKeyToCookie()"
            style="background:#17a2b8; font-size:12px; padding:4px 8px;">ğŸ’¾ ä¿å­˜åˆ°æœ¬åœ°</button>
          <button type="button" onclick="clearPrivateKeyCookie()"
            style="background:#dc3545; font-size:12px; padding:4px 8px; margin-left:6px;">ğŸ—‘ï¸ æ¸…é™¤æœ¬åœ°</button>
        </div>
      </div>
      <div id="transactionDetail" class="hidden">
        <h3>äº‹åŠ¡è¯¦æƒ…ï¼š<span id="txnUsername"></span></h3>

        <!-- å“ˆå¸Œä¿¡æ¯ï¼ˆå…¨éƒ¨ç”¨ textarea è‡ªåŠ¨æ¢è¡Œï¼‰ -->
        <div class="form-group">
          <label>ç­¾åæ–‡ä»¶å“ˆå¸Œï¼ˆæ¥è‡ª.signatureï¼‰ï¼š</label>
          <textarea id="sigHash" readonly rows="2"></textarea>
        </div>
        <div class="form-group">
          <label>å®é™… JSON æ–‡ä»¶å“ˆå¸Œï¼š</label>
          <textarea id="actualHash" readonly rows="2"></textarea>
        </div>
        <div class="form-group">
          <label>å“ˆå¸Œä¸€è‡´ï¼Ÿ</label>
          <span id="hashMatchStatus"></span>
        </div>

        <div class="form-group">
          <label>ç­¾åä¸­çš„å¯†ç å“ˆå¸Œï¼ˆæ¥è‡ª .signature çš„ P å­—æ®µï¼‰ï¼š</label>
          <textarea id="claimedPwdHash" readonly rows="1"></textarea>
        </div>
        <div class="form-group">
          <label>æœåŠ¡å™¨å­˜å‚¨çš„å¯†ç å“ˆå¸Œï¼ˆä» .pwd æ–‡ä»¶è§£å¯†ï¼‰ï¼š</label>
          <textarea id="storedPwdHash" readonly rows="1"></textarea>
        </div>
        <div class="form-group">
          <label>å¯†ç å“ˆå¸Œä¸€è‡´ï¼Ÿ</label>
          <span id="pwdHashMatchStatus"></span>
        </div>

        <!-- å¹¶æ’å¯¹æ¯”åŒºåŸŸ -->
        <div style="display: flex; gap: 16px; margin-top: 16px;">
          <div style="flex: 1;">
            <label>ğŸ“„ å®Œæ•´ JSON é…ç½®ï¼ˆæ¥è‡ª.signatureåŒå.jsonï¼‰ï¼š</label>
            <pre id="txnJsonPreview"
              style="background:#f8f9fa; padding:10px; border-radius:4px; overflow:auto; white-space: pre-wrap; word-break: break-all;"></pre>
          </div>
          <div style="flex: 1;">
            <label>ğŸ“œ .signature åŸå§‹å†…å®¹ï¼ˆBase64 è§£ç åï¼‰ï¼š</label>
            <textarea id="signatureRawContent" readonly rows="10"
              style="width:100%; font-family: monospace;"></textarea>
          </div>
        </div>

        <button onclick="approveTransaction()" style="background:#28a745;">âœ… æäº¤</button>
        <button onclick="rejectTransaction()" style="background:#dc3545; margin-left:8px;">âŒ é©³å›</button>
        <button onclick="hideTransactionDetail()" style="background:#6c757d; margin-left:8px;">â¬…ï¸ è¿”å›åˆ—è¡¨</button>
      </div>
    </div>

    <div id="statusMessage" class="status hidden"></div>
  </div>

  <script>
    // ========== å…¨å±€çŠ¶æ€ ==========
    let currentUsername = '';
    let isExistingUser = false;
    let userFields = [];
    const userFieldStates = {};
    const allUsers = [];
    let currentTxnUsername = '';
    const PUBLIC_BUCKET = 'talon-public-1258609989';
    const ADMIN_BUCKET = 'talon-admin-1258609989';
    const REGION = 'ap-chongqing';

    const HERO_LIST = [
      "doomfist", "cassidy", "genji", "pharah", "reaper", "soldier-76", "sombra", "tracer",
      "bastion", "hanzo", "junkrat", "mei", "torbjorn", "widowmaker", "ashe", "echo", "sojourn",
      "ana", "baptiste", "brigitte", "lucio", "mercy", "moira", "zenyatta", "kiriko", "lifeweaver",
      "sigma", "orisa", "ramattra", "reinhardt", "roadhog", "winston", "wrecking-ball", "zarya", "dva",
      "junker-queen", "mauga", "hazard", "freja", "juno", "wuyang", "venture", "symmetra", "illari"
    ];

    const RSA_PUBLIC_KEY_PEM = `-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsoywmxv9e4Td4yp9g4blKpfQvjBXc+Hp7/I+el7aSzozm1awUXssKoAzXvvI9O2SpZ/1I6qH8lm3+cRmuKflnKbwdIWC0njlhJLVuNWWhGFZE3H+sD1Ntmv4F1LARFVe17LcO6GzfmFLFnBYeGnlwsheIlz6tSqq5pfExMCwkWR5vcltfYi1s1mF+i+69M3YzNOEpzkkXsvWrXSmpncAeeQ4cVYAxpWQMLbG4ozwxWSo6xLsM9a5TNKAYKVOuJVbBBfNvmbd/7wGbIkV4yPKRslt7C0rskkC4qjr+AwYoo+DryivVhnMLnehGiUjcFn7FX4EvZmZb8OCLId8510gmQIDAQAB
-----END PUBLIC KEY-----`;

    // ========== å·¥å…·å‡½æ•° ==========
    function showStatus(msg, isError = false) {
      const el = document.getElementById('statusMessage');
      el.textContent = msg;
      el.className = `status ${isError ? 'error' : 'success'}${!msg ? ' hidden' : ''}`;
    }

    function generateFieldId() {
      return 'field-' + Date.now() + '-' + Math.random().toString(36).substr(2, 5);
    }

    // ========== å¯†ç åŠ å¯†ï¼ˆä¿æŒä¸å˜ï¼‰==========
    async function sha256FullHex(password) {
      const encoder = new TextEncoder();
      const data = encoder.encode(password);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    async function sha256Truncated(password) {
      const full = await sha256FullHex(password);
      return full.substring(0, 16).toUpperCase();
    }

    async function importRsaPublicKey(pem) {
      const pemContents = pem.replace(/-----BEGIN PUBLIC KEY-----/, '')
        .replace(/-----END PUBLIC KEY-----/, '')
        .replace(/\s/g, '');
      const binaryDerString = atob(pemContents);
      const binaryDer = new Uint8Array(binaryDerString.length);
      for (let i = 0; i < binaryDerString.length; i++) {
        binaryDer[i] = binaryDerString.charCodeAt(i);
      }
      return await crypto.subtle.importKey('spki', binaryDer.buffer, { name: 'RSA-OAEP', hash: 'SHA-256' }, true, ['encrypt']);
    }

    async function rsaEncrypt(publicKey, plaintext) {
      const encoder = new TextEncoder();
      const encoded = encoder.encode(plaintext);
      const encrypted = await crypto.subtle.encrypt({ name: 'RSA-OAEP' }, publicKey, encoded);
      return btoa(String.fromCharCode(...new Uint8Array(encrypted)));
    }

    // ========== å­—æ®µç®¡ç†ï¼ˆä¿æŒä¸å˜ï¼‰==========
    function renderUserFields(parentId = null, container = null) {
      if (parentId === null) {
        const rootContainer = document.getElementById('userFieldsContainer');
        rootContainer.innerHTML = '';
        userFields.forEach(field => {
          const el = createFieldElement(field);
          rootContainer.appendChild(el);
        });
      } else {
        const subContainer = container || document.querySelector(`[data-field-id="${parentId}"] .sub-fields-container`);
        if (!subContainer) return;
        subContainer.innerHTML = '';
        const parentField = findFieldById(parentId);
        if (!parentField || !parentField.children) return;
        parentField.children.forEach(child => {
          const el = createFieldElement(child);
          subContainer.appendChild(el);
        });
      }
    }

    function findFieldById(id, fields = userFields) {
      for (const f of fields) {
        if (f.id === id) return f;
        if (f.children) {
          const found = findFieldById(id, f.children);
          if (found) return found;
        }
      }
      return null;
    }

    function createFieldElement(field) {
      const div = document.createElement('div');
      div.className = 'field-item';
      div.dataset.fieldId = field.id;

      const isProtected = field.name === 'PWD16Byte' || field.name === 'hero' || field.name === 'ID';
      const isHero = field.name === 'hero';
      const isPwd = field.name === 'PWD16Byte';

      const header = document.createElement('div');
      header.className = 'field-header';

      const badge = document.createElement('span');
      badge.className = `field-type-badge ${field.type}`;
      badge.textContent = field.type;

      const nameSpan = document.createElement('span');
      nameSpan.textContent = field.name || '(unnamed)';
      nameSpan.style.cursor = 'pointer';
      nameSpan.style.flexGrow = '1';
      nameSpan.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleFieldEdit(field.id);
      });

      const actions = document.createElement('div');
      actions.className = 'field-actions';
      if (!isProtected) {
        const deleteBtn = document.createElement('span');
        deleteBtn.className = 'delete-btn';
        deleteBtn.textContent = 'Ã—';
        deleteBtn.style.cursor = 'pointer';
        deleteBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          deleteUserField(field.id);
        });
        actions.appendChild(deleteBtn);
      }

      header.appendChild(badge);
      header.appendChild(nameSpan);
      header.appendChild(actions);

      const form = document.createElement('div');
      form.className = 'field-edit-form';
      form.id = `${field.id}-form`;
      form.style.display = userFieldStates[field.id] ? 'block' : 'none';

      if (isPwd) {
        form.innerHTML = `<div><strong>PWD16Byte å€¼:</strong> <code>${field.value || 'æœªè®¾ç½®'}</code></div>`;
      } else if (isHero) {
        const heroList = Array.isArray(field.value) ? field.value : [];
        let heroHtml = '<div class="hero-list">';
        HERO_LIST.forEach(hero => {
          const isChecked = heroList.includes(hero);
          heroHtml += `
            <button type="button"
                    onclick="toggleHero('${field.id}', '${hero}')"
                    style="
                      background: ${isChecked ? '#1e8449' : '#2ecc71'};
                      color: white;
                      border: 2px solid ${isChecked ? '#145a32' : '#27ae60'};
                      font-weight: bold;
                      margin: 2px;
                      padding: 4px 6px;
                      font-size: 12px;
                      border-radius: 3px;
                    ">
              ${hero}
            </button>`;
        });
        heroHtml += '</div>';
        form.innerHTML = heroHtml;
      } else if (field.type === 'object' || field.type === 'array') {
        form.innerHTML = `
          <input type="text" placeholder="å­—æ®µå" value="${field.name || ''}" onchange="updateFieldName('${field.id}', this.value)">
          <select onchange="updateFieldType('${field.id}', this.value)">
            <option value="string" ${field.type === 'string' ? 'selected' : ''}>String</option>
            <option value="number" ${field.type === 'number' ? 'selected' : ''}>Number</option>
            <option value="boolean" ${field.type === 'boolean' ? 'selected' : ''}>Boolean</option>
            <option value="object" ${field.type === 'object' ? 'selected' : ''}>Object</option>
            <option value="array" ${field.type === 'array' ? 'selected' : ''}>Array</option>
          </select>
          <button type="button" onclick="addUserField('${field.id}')" style="margin-top:6px; background:#3498db;">â• æ·»åŠ å­å­—æ®µ</button>
          <div class="sub-fields-container"></div>
        `;
        setTimeout(() => renderUserFields(field.id, form.querySelector('.sub-fields-container')), 0);
      } else {
        const valueStr = typeof field.value === 'string' ? field.value : JSON.stringify(field.value, null, 2);
        form.innerHTML = `
          <input type="text" placeholder="å­—æ®µå" value="${field.name || ''}" onchange="updateFieldName('${field.id}', this.value)">
          <select onchange="updateFieldType('${field.id}', this.value)">
            <option value="string" ${field.type === 'string' ? 'selected' : ''}>String</option>
            <option value="number" ${field.type === 'number' ? 'selected' : ''}>Number</option>
            <option value="boolean" ${field.type === 'boolean' ? 'selected' : ''}>Boolean</option>
            <option value="object" ${field.type === 'object' ? 'selected' : ''}>Object</option>
            <option value="array" ${field.type === 'array' ? 'selected' : ''}>Array</option>
          </select>
          <textarea placeholder="å€¼ (JSONæ ¼å¼)" rows="2" onchange="updateFieldValue('${field.id}', this.value)">${valueStr}</textarea>
        `;
      }

      div.appendChild(header);
      div.appendChild(form);
      return div;
    }

    function toggleFieldEdit(fieldId) {
      const wasExpanded = userFieldStates[fieldId];
      userFieldStates[fieldId] = !wasExpanded;
      const form = document.getElementById(`${fieldId}-form`);
      if (form) form.style.display = userFieldStates[fieldId] ? 'block' : 'none';
      if (!userFieldStates[fieldId]) collapseAllChildren(fieldId);
    }

    function collapseAllChildren(parentId) {
      const descendants = getAllDescendantFieldIds(parentId);
      descendants.forEach(id => {
        userFieldStates[id] = false;
        const form = document.getElementById(`${id}-form`);
        if (form) form.style.display = 'none';
      });
    }

    function getAllDescendantFieldIds(parentId) {
      const descendants = [];
      const parent = findFieldById(parentId);
      if (!parent || !parent.children) return descendants;
      function collect(fields) {
        for (const f of fields) {
          descendants.push(f.id);
          if (f.children && f.children.length > 0) collect(f.children);
        }
      }
      collect(parent.children);
      return descendants;
    }

    function addUserField(parentId = null) {
      const newId = generateFieldId();
      const newField = { id: newId, name: '', type: 'string', value: '', children: [] };
      if (parentId === null) {
        userFields.push(newField);
      } else {
        const parent = findFieldById(parentId);
        if (parent) {
          if (!parent.children) parent.children = [];
          parent.children.push(newField);
        }
      }
      userFieldStates[newId] = true;
      renderUserFields();
    }

    function deleteUserField(id) {
      const deleteFrom = (fields) => {
        for (let i = 0; i < fields.length; i++) {
          if (fields[i].id === id) {
            fields.splice(i, 1);
            return true;
          }
          if (fields[i].children && deleteFrom(fields[i].children)) return true;
        }
        return false;
      };
      deleteFrom(userFields);
      renderUserFields();
    }

    function updateFieldName(id, name) {
      const field = findFieldById(id);
      if (!field || field.name === 'PWD16Byte' || field.name === 'hero') return;
      field.name = name;
    }

    function updateFieldType(id, type) {
      const field = findFieldById(id);
      if (!field || field.name === 'PWD16Byte' || field.name === 'hero') return;
      field.type = type;
      if (type === 'object') {
        field.value = {};
        field.children = field.children || [];
      } else if (type === 'array') {
        field.value = [];
        field.children = field.children || [];
      } else if (type === 'boolean') {
        field.value = false;
        field.children = [];
      } else {
        field.value = '';
        field.children = [];
      }
      renderUserFields();
    }

    function updateFieldValue(id, valueStr) {
      const field = findFieldById(id);
      if (!field || field.name === 'PWD16Byte' || field.name === 'hero') return;
      try {
        field.value = JSON.parse(valueStr);
      } catch (e) {
        field.value = valueStr;
      }
    }

    function toggleHero(fieldId, heroName) {
      const field = findFieldById(fieldId);
      if (!field || field.name !== 'hero') return;
      if (!Array.isArray(field.value)) field.value = [];
      const index = field.value.indexOf(heroName);
      if (index === -1) field.value.push(heroName);
      else field.value.splice(index, 1);
      renderUserFields();
    }

    function loadFieldsFromJson(data, parentId = null) {
      const fields = [];
      for (const [key, value] of Object.entries(data)) {
        const isArray = Array.isArray(value);
        const isObj = !isArray && value !== null && typeof value === 'object';
        const field = {
          id: generateFieldId(),
          name: key,
          type: isArray ? 'array' : (isObj ? 'object' : typeof value),
          value: value,
          children: []
        };
        if (isObj || isArray) {
          field.children = loadFieldsFromJson(value, field.id);
        }
        fields.push(field);
      }
      if (parentId === null) userFields = fields;
      return fields;
    }

    function exportFieldsToJson(fields = userFields) {
      const result = {};
      for (const field of fields) {
        if (!field.name) continue;
        if (field.name === 'hero') {
          result.hero = Array.isArray(field.value) ? field.value : [];
          continue;
        }
        if (field.name === 'PWD16Byte') {
          result.PWD16Byte = field.value;
          continue;
        }
        if (field.type === 'object' || field.type === 'array') {
          result[field.name] = exportFieldsToJson(field.children);
        } else {
          result[field.name] = field.value;
        }
      }
      return result;
    }

    // ========== ç”¨æˆ·ç®¡ç† ==========
    async function loadUserList() {
      try {
        const res = await fetch('/api/users/list');
        if (!res.ok) throw new Error('æ— æ³•è·å–ç”¨æˆ·åˆ—è¡¨');
        const users = await res.json();
        allUsers.length = 0;
        allUsers.push(...users);
        renderUserList();
      } catch (err) {
        showStatus('åŠ è½½ç”¨æˆ·åˆ—è¡¨å¤±è´¥: ' + err.message, true);
        document.getElementById('userList').innerHTML = '<p>âŒ åŠ è½½å¤±è´¥</p>';
      }
    }

    function renderUserList() {
      const container = document.getElementById('userList');
      if (allUsers.length === 0) {
        container.innerHTML = '<p>æš‚æ— ç”¨æˆ·ï¼Œç‚¹å‡»ä¸Šæ–¹â€œåˆ›å»ºæ–°ç”¨æˆ·â€å¼€å§‹ã€‚</p>';
        return;
      }
      let html = '';
      for (const username of allUsers) {
        html += `

<div class="user-card">
  <div style="flex: 1; min-width: 0;">
    <strong>${username}</strong>
  </div>
  <div class="action-buttons">
    <button onclick="editUser('alice')">âœï¸ ç¼–è¾‘</button>
    <button onclick="deleteUser('alice')" style="background:#dc3545;">ğŸ—‘ï¸ åˆ é™¤</button>
  </div>
</div>
    `;
      }
      container.innerHTML = html;
    }

    function createNewUser() {
      const username = prompt('è¯·è¾“å…¥æ–°ç”¨æˆ·åï¼š');
      if (!username || !username.trim()) {
        showStatus('ç”¨æˆ·åä¸èƒ½ä¸ºç©º', true);
        return;
      }
      const cleanName = username.trim();
      if (allUsers.includes(cleanName)) {
        showStatus('ç”¨æˆ·å·²å­˜åœ¨', true);
        return;
      }
      enterEditUser(cleanName, false);
    }

    async function editUser(username) {
      enterEditUser(username, true);
    }

    async function enterEditUser(username, isExisting) {
      currentUsername = username;
      isExistingUser = isExisting;

      try {
        if (isExisting) {
          const res = await fetch(`/api/user/${encodeURIComponent(username)}`);
          if (!res.ok) throw new Error('ç”¨æˆ·æ•°æ®åŠ è½½å¤±è´¥');
          const userData = await res.json();
          loadFieldsFromJson(userData);
        } else {
          userFields = [
            { id: generateFieldId(), name: 'ID', type: 'string', value: username, children: [] },
            { id: generateFieldId(), name: 'hero', type: 'array', value: [], children: [] },
            { id: generateFieldId(), name: 'PWD16Byte', type: 'string', value: '', children: [] }
          ];
        }

        // ğŸ‘‡ å…³é”®ï¼šåˆå§‹åŒ–æ—¶éšè—å¯†ç åŒºåŸŸ
        document.getElementById('passwordSection').classList.add('hidden');
        document.getElementById('passwordInput').value = '';

        document.getElementById('editingUsernameDisplay').textContent = username;
        document.getElementById('userForm').classList.remove('hidden');
        document.getElementById('userList').classList.add('hidden');
        renderUserFields();
        showStatus('');
      } catch (err) {
        showStatus('åŠ è½½ç”¨æˆ·å¤±è´¥: ' + err.message, true);
      }
    }

    function cancelEdit() {
      document.getElementById('userForm').classList.add('hidden');
      document.getElementById('userList').classList.remove('hidden');
    }

    async function saveUser() {
      const password = document.getElementById('passwordInput').value;
      const shouldUpdatePassword = !isExistingUser ? !!password : password !== '';

      if (!isExistingUser && !password) {
        return showStatus('æ–°ç”¨æˆ·å¿…é¡»è®¾ç½®å¯†ç ', true);
      }

      let encryptedPwdBase64 = null;
      const userData = exportFieldsToJson();

      if (shouldUpdatePassword) {
        try {
          showStatus('æ­£åœ¨åŠ å¯†å¯†ç ...');
          userData.PWD16Byte = await sha256Truncated(password);
          const passwordHashHex = await sha256FullHex(password);
          const publicKey = await importRsaPublicKey(RSA_PUBLIC_KEY_PEM);
          encryptedPwdBase64 = await rsaEncrypt(publicKey, passwordHashHex);
        } catch (err) {
          console.error('å¯†ç å¤„ç†å¤±è´¥:', err);
          return showStatus('å¯†ç åŠ å¯†å¤±è´¥ï¼Œè¯·æ£€æŸ¥å…¬é’¥', true);
        }
      }

      try {
        const payload = {
          username: currentUsername,
          data: userData,
          isNew: !isExistingUser,
          encryptedPassword: encryptedPwdBase64,
          updatePassword: shouldUpdatePassword
        };

        const res = await fetch('/api/user/save', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        if (res.ok) {
          showStatus('âœ… ä¿å­˜æˆåŠŸï¼');
          isExistingUser = true;
          if (shouldUpdatePassword) {
            document.getElementById('passwordInput').value = '';
          }
          // è¿”å›åˆ—è¡¨å¹¶åˆ·æ–°
          setTimeout(() => {
            document.getElementById('userForm').classList.add('hidden');
            document.getElementById('userList').classList.remove('hidden');
            loadUserList();
          }, 1000);
        } else {
          const err = await res.json();
          showStatus('âŒ ä¿å­˜å¤±è´¥: ' + (err.error || 'æœªçŸ¥é”™è¯¯'), true);
        }
      } catch (err) {
        showStatus('ç½‘ç»œé”™è¯¯: ' + err.message, true);
      }
    }

    async function deleteUser(username) {
      if (!confirm(`ç¡®å®šè¦åˆ é™¤ç”¨æˆ· "${username}" å—ï¼Ÿæ­¤æ“ä½œä¼šå°†å…¶ç§»å…¥å›æ”¶ç«™ã€‚`)) return;

      try {
        const res = await fetch('/api/user/delete', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username })
        });

        if (res.ok) {
          showStatus(`âœ… ç”¨æˆ· "${username}" å·²ç§»è‡³å›æ”¶ç«™`);
          loadUserList();
        } else {
          const err = await res.json();
          showStatus('âŒ åˆ é™¤å¤±è´¥: ' + (err.error || 'æœªçŸ¥é”™è¯¯'), true);
        }
      } catch (err) {
        showStatus('ç½‘ç»œé”™è¯¯: ' + err.message, true);
      }
    }

    function togglePasswordSection() {
      const section = document.getElementById('passwordSection');
      const isHidden = section.classList.contains('hidden');
      if (isHidden) {
        section.classList.remove('hidden');
        // å¯é€‰ï¼šèšç„¦åˆ°è¾“å…¥æ¡†
        document.getElementById('passwordInput').focus();
      } else {
        section.classList.add('hidden');
        // æ¸…ç©ºè¾“å…¥ï¼ˆé¿å…è¯¯ä¿å­˜ï¼‰
        document.getElementById('passwordInput').value = '';
      }
    }


    // ========== äº‹åŠ¡ç®¡ç† ==========

    let currentTxnFolder = '';
    let currentTxnFilename = '';

    async function loadTransactionList() {
      try {
        const res = await fetch('/api/transactions/list');
        if (!res.ok) throw new Error('æ— æ³•è·å–äº‹åŠ¡åˆ—è¡¨');
        const signaturePaths = await res.json();
        renderTransactionList(signaturePaths);
      } catch (err) {
        showStatus('åŠ è½½äº‹åŠ¡å¤±è´¥: ' + err.message, true);
        document.getElementById('transactionList').innerHTML = '<p>âŒ åŠ è½½å¤±è´¥</p>';
      }
    }

    async function renderTransactionList(signaturePaths) {
      const container = document.getElementById('transactionList');
      if (signaturePaths.length === 0) {
        container.innerHTML = '<p>æš‚æ— å¾…å®¡æ ¸äº‹åŠ¡ã€‚</p>';
        return;
      }

      // å°è¯•è·å–ç§é’¥ï¼ˆä¼˜å…ˆé¡µé¢è¾“å…¥ï¼Œå…¶æ¬¡ Cookieï¼‰
      let privateKeyPem = document.getElementById('privateKeyInput').value.trim();
      if (!privateKeyPem) {
        loadPrivateKeyFromCookie(); // è‡ªåŠ¨å¡«å……åˆ°è¾“å…¥æ¡†
        privateKeyPem = document.getElementById('privateKeyInput').value.trim();
      }

      // å¼€å§‹æ„å»ºåˆ—è¡¨é¡¹ï¼ˆå¸¦å¼‚æ­¥è§£æï¼‰
      container.innerHTML = '<p>æ­£åœ¨è§£æäº‹åŠ¡èº«ä»½ä¿¡æ¯...</p>';

      const items = [];
      for (const sigPath of signaturePaths) {
        const lastSlash = sigPath.lastIndexOf('/');
        const folder = lastSlash > -1 ? sigPath.substring(0, lastSlash) : '';
        const filename = lastSlash > -1 ? sigPath.substring(lastSlash + 1) : sigPath;

        let displayId = folder || 'æœªçŸ¥ç”¨æˆ·';
        let timestampStr = '';

        if (privateKeyPem) {
          try {
            // è·å– .signature åŸå§‹å†…å®¹ï¼ˆBase64ï¼‰
            const rawUrl = `/api/transaction/${encodeURIComponent(folder)}/${encodeURIComponent(filename)}/raw`;
            const res = await fetch(rawUrl);
            if (res.ok) {
              const data = await res.json(); // { signature: "base64...", jsonData: "..." }
              const decryptedBytes = await rsaDecryptFromPem(privateKeyPem, data.signature);
              const decryptedText = new TextDecoder().decode(decryptedBytes);
              const payload = JSON.parse(decryptedText);

              if (payload && typeof payload === 'object') {
                displayId = payload.ID || folder || 'æœªæä¾›ID';
                if (payload.T) {
                  const time = new Date(parseInt(payload.T));
                  if (!isNaN(time.getTime())) {
                    timestampStr = ` | ${time.toLocaleString('zh-CN')}`;
                  }
                }
              }
            }
          } catch (e) {
            console.warn('è§£æäº‹åŠ¡ ID å¤±è´¥:', sigPath, e);
            displayId = `${folder}ï¼ˆIDè§£æå¤±è´¥ï¼‰`;
          }
        } else {
          displayId = `${folder}ï¼ˆéœ€ç§é’¥è§£æIDï¼‰`;
        }

        items.push({ folder, filename, displayId, timestampStr });
      }

      // æ¸²æŸ“æœ€ç»ˆåˆ—è¡¨
      let html = '';
      for (const item of items) {
        html += `
      <div class="transaction-card">
        <strong>${item.displayId}</strong>
        <small style="display:block;color:#666;margin-top:4px;">
          ${item.folder}/${item.filename}${item.timestampStr}
        </small>
        <button type="button" 
                onclick="viewTransaction('${encodeURIComponent(item.folder)}','${encodeURIComponent(item.filename)}')" 
                style="float:right; background:#ffc107; color:black;">ğŸ” æŸ¥çœ‹</button>
      </div>`;
      }
      container.innerHTML = html;
    }

    // å…¨å±€ç¼“å­˜ç§é’¥ï¼ˆä»…å†…å­˜ä¸­ï¼Œåˆ·æ–°å³ä¸¢ï¼‰
    let tempPrivateKey = '';

    async function viewTransaction(folder, filename) {
      currentTxnFolder = decodeURIComponent(folder);
      currentTxnFilename = decodeURIComponent(filename);

      const jsonFilename = currentTxnFilename.replace(/\.signature$/i, '.json');
      if (jsonFilename === currentTxnFilename) {
        alert('äº‹åŠ¡æ–‡ä»¶å¿…é¡»ä»¥ .signature ç»“å°¾');
        return;
      }

      document.getElementById('privateKeySection').style.display = 'none';
      const pagePrivateKey = document.getElementById('privateKeyInput').value.trim();
      if (pagePrivateKey) tempPrivateKey = pagePrivateKey;
      if (!tempPrivateKey) {
        alert('è¯·å…ˆç²˜è´´ RSA ç§é’¥');
        document.getElementById('privateKeyInput').focus();
        return;
      }

      try {
        // Step 1: è·å– .signature å†…å®¹ï¼ˆBase64ï¼‰
        const rawUrl = `/api/transaction/${encodeURIComponent(currentTxnFolder)}/${encodeURIComponent(currentTxnFilename)}/raw`;
        const sigRes = await fetch(rawUrl);
        if (!sigRes.ok) throw new Error('åŠ è½½ç­¾åå¤±è´¥');
        const { signature: signatureBase64, sigKey } = await sigRes.json();

        // Step 2: æ„é€  .json çš„å…¬å¼€ COS URL å¹¶ç›´æ¥ fetch
        const jsonUrl = `https://${PUBLIC_BUCKET}.cos.${REGION}.myqcloud.com/${encodeURIComponent(currentTxnFolder)}/${encodeURIComponent(jsonFilename)}`;
        let jsonDataStr = '{}';
        try {
          const jsonRes = await fetch(jsonUrl);
          if (jsonRes.ok) {
            const rawText = await jsonRes.text();
            // å°è¯•æ ‡å‡†åŒ–ä¸º profile.html çš„æ ¼å¼
            try {
              const obj = JSON.parse(rawText);
              jsonDataStr = JSON.stringify(obj, null, 2);
            } catch (parseErr) {
              // å¦‚æœä¸æ˜¯åˆæ³• JSONï¼Œä¿ç•™åŸå§‹æ–‡æœ¬ï¼ˆå¦‚ç©ºæ–‡ä»¶ï¼‰
              jsonDataStr = rawText;
            }
          }
        } catch (e) {
          console.warn('è·å– .json æ–‡ä»¶å¤±è´¥:', e);
        }

        // Step 3: è®¡ç®—å®é™… JSON å“ˆå¸Œ
        const encoder = new TextEncoder();
        const jsonBytes = encoder.encode(jsonDataStr);
        const actualHashBuffer = await crypto.subtle.digest('SHA-256', jsonBytes);
        const fullActualHashHex = Array.from(new Uint8Array(actualHashBuffer))
          .map(b => b.toString(16).padStart(2, '0')).join('');
        const actualHashHex = fullActualHashHex.substring(0, 32);

        // Step 4: è§£å¯† signature
        let decryptedText = '';
        let sigHashHex = '';
        let claimedPwdHash = '';
        let timestampMs = null;
        let userIdFromSig = null;
        let isValidSig = false;

        try {
          const decrypted = await rsaDecryptFromPem(tempPrivateKey, signatureBase64);
          decryptedText = new TextDecoder().decode(decrypted);
          const payload = JSON.parse(decryptedText);
          if (payload && typeof payload === 'object') {
            sigHashHex = (payload.F || '').toLowerCase();
            claimedPwdHash = (payload.P || '').toLowerCase();
            timestampMs = payload.T;
            userIdFromSig = payload.ID;
            isValidSig = /^[a-f0-9]{32}$/.test(sigHashHex) && sigHashHex === actualHashHex;
          } else {
            sigHashHex = '(æ— æ•ˆæ ¼å¼)';
          }
        } catch (e) {
          console.error('è§£å¯†å¤±è´¥:', e);
          decryptedText = `âŒ è§£å¯†å¤±è´¥: ${e.message}`;
          sigHashHex = '(è§£å¯†å¤±è´¥)';
        }

        // Step 5: è·å– .pwd æ–‡ä»¶ï¼ˆä»éœ€é€šè¿‡ ID æ„é€  COS URLï¼‰
        let storedFullHash = '';
        let pwdFileValid = false;
        if (userIdFromSig) {
          try {
            const pwdUrl = `https://${ADMIN_BUCKET}.cos.${REGION}.myqcloud.com/${encodeURIComponent(userIdFromSig)}/${encodeURIComponent(userIdFromSig)}.pwd`;
            const pwdRes = await fetch(pwdUrl);
            if (pwdRes.ok) {
              const pwdBase64 = await pwdRes.text();
              const pwdDecryptedBytes = await rsaDecryptFromPem(tempPrivateKey, pwdBase64.trim());
              storedFullHash = new TextDecoder().decode(pwdDecryptedBytes).toLowerCase();
              pwdFileValid = /^[a-f0-9]{64}$/.test(storedFullHash);
            } else {
              storedFullHash = `(æœªæ‰¾åˆ° .pwd æ–‡ä»¶ï¼ŒID: ${userIdFromSig})`;
            }
          } catch (e) {
            storedFullHash = `(è§£å¯† .pwd å¤±è´¥: ${e.message})`;
          }
        } else {
          storedFullHash = '(ç­¾åä¸­æœªæä¾› IDï¼Œæ— æ³•åŠ è½½ .pwd)';
        }

        const pwdHashMatch = pwdFileValid && claimedPwdHash === storedFullHash;

        // Step 6: æ›´æ–° UI
        const displayId = userIdFromSig || currentTxnFolder || 'æœªçŸ¥ç”¨æˆ·';
        let titleText = `${displayId} (${currentTxnFilename})`;
        if (timestampMs) {
          const timeStr = new Date(parseInt(timestampMs)).toLocaleString('zh-CN');
          titleText += ` | ${timeStr}`;
        }
        document.getElementById('txnUsername').textContent = titleText;

        document.getElementById('sigHash').value = sigHashHex;
        document.getElementById('actualHash').value = actualHashHex;
        document.getElementById('claimedPwdHash').value = claimedPwdHash || '(æ—  P å­—æ®µ)';
        document.getElementById('storedPwdHash').value = storedFullHash;

        const matchEl = document.getElementById('hashMatchStatus');
        matchEl.className = isValidSig ? 'hash-match' : 'hash-mismatch';
        matchEl.textContent = isValidSig ? 'âœ… ä¸€è‡´' : 'âŒ ä¸ä¸€è‡´';

        const pwdMatchEl = document.getElementById('pwdHashMatchStatus');
        pwdMatchEl.className = pwdHashMatch ? 'hash-match' : 'hash-mismatch';
        pwdMatchEl.textContent = pwdHashMatch ? 'âœ… ä¸€è‡´' : 'âŒ ä¸ä¸€è‡´';

        document.getElementById('signatureRawContent').value = decryptedText;

        let formattedJson = jsonDataStr;
        try {
          formattedJson = JSON.stringify(JSON.parse(jsonDataStr), null, 2);
        } catch (e) {
          // ä¿ç•™åŸå§‹å­—ç¬¦ä¸²
        }
        document.getElementById('txnJsonPreview').textContent = formattedJson;
        document.getElementById('privateKeyInput').value = tempPrivateKey;

        document.getElementById('transactionDetail').classList.remove('hidden');
        document.getElementById('transactionList').classList.add('hidden');
      } catch (err) {
        showStatus('æŸ¥çœ‹äº‹åŠ¡å¤±è´¥: ' + err.message, true);
      }
    }

    // ====== RSA ç§é’¥è§£å¯†ï¼ˆPKCS#8 PEM -> CryptoKey -> decryptï¼‰======
    async function importRsaPrivateKey(pem) {
      // å»é™¤ PEM å¤´å°¾å’Œç©ºæ ¼
      const pemContents = pem
        .replace(/-----BEGIN PRIVATE KEY-----/, '')
        .replace(/-----END PRIVATE KEY-----/, '')
        .replace(/\s/g, '');

      // Base64 è§£ç ä¸ºäºŒè¿›åˆ¶
      const binaryDerString = atob(pemContents);
      const binaryDer = new Uint8Array(binaryDerString.length);
      for (let i = 0; i < binaryDerString.length; i++) {
        binaryDer[i] = binaryDerString.charCodeAt(i);
      }

      // å¯¼å…¥ç§é’¥ï¼ˆå¿…é¡»æŒ‡å®š extractable: true å’Œ decrypt æƒé™ï¼‰
      return await crypto.subtle.importKey(
        'pkcs8',
        binaryDer.buffer,
        {
          name: 'RSA-OAEP',
          hash: 'SHA-256'
        },
        true,
        ['decrypt']
      );
    }

    async function rsaDecryptFromPem(privateKeyPem, base64Ciphertext) {
      const privateKey = await importRsaPrivateKey(privateKeyPem);
      const ciphertext = Uint8Array.from(atob(base64Ciphertext), c => c.charCodeAt(0));
      const plaintext = await crypto.subtle.decrypt(
        { name: 'RSA-OAEP' },
        privateKey,
        ciphertext
      );
      return new Uint8Array(plaintext);
    }

    function highlightJsonFields(jsonStr, modifiedKeys = []) {
      try {
        const obj = JSON.parse(jsonStr);
        const seen = new Set();

        function walk(current, path = '') {
          if (current === null || typeof current !== 'object') return JSON.stringify(current);

          if (Array.isArray(current)) {
            return '[' + current.map((item, i) => walk(item, `${path}[${i}]`)).join(', ') + ']';
          }

          const entries = Object.entries(current).map(([key, val]) => {
            const fullPath = path ? `${path}.${key}` : key;
            const isModified = modifiedKeys.some(k => fullPath === k || fullPath.startsWith(k + '.'));
            const valStr = walk(val, fullPath);
            const quotedKey = `"${key}"`;
            const pair = `${quotedKey}: ${valStr}`;
            if (isModified && !seen.has(fullPath)) {
              seen.add(fullPath);
              return `<span style="background:yellow">${pair}</span>`;
            }
            return pair;
          });
          return '{' + entries.join(', ') + '}';
        }

        return walk(obj);
      } catch (e) {
        return jsonStr.replace(/&/g, '&amp;').replace(/</g, '&lt;');
      }
    }


    async function approveTransaction() {
      if (!confirm(`ç¡®å®šè¦æäº¤ "${currentTxnFolder}/${currentTxnFilename}" å—ï¼Ÿ`)) return;
      try {
        const url = `/api/transaction/${encodeURIComponent(currentTxnFolder)}/${encodeURIComponent(currentTxnFilename)}/commit`;
        const res = await fetch(url, { method: 'POST' });
        if (res.ok) {
          showStatus('âœ… æäº¤æˆåŠŸï¼');
          hideTransactionDetail();
          loadTransactionList();
          loadUserList();
        } else {
          const err = await res.json();
          showStatus('æäº¤å¤±è´¥: ' + (err.error || 'æœªçŸ¥é”™è¯¯'), true);
        }
      } catch (err) {
        showStatus('ç½‘ç»œé”™è¯¯: ' + err.message, true);
      }
    }

    async function rejectTransaction() {
      if (!confirm(`ç¡®å®šè¦é©³å› "${currentTxnFolder}/${currentTxnFilename}" å—ï¼Ÿ`)) return;
      try {
        const url = `/api/transaction/${encodeURIComponent(currentTxnFolder)}/${encodeURIComponent(currentTxnFilename)}/reject`;
        const res = await fetch(url, { method: 'POST' });
        if (res.ok) {
          showStatus('âœ… å·²é©³å›å¹¶å½’æ¡£');
          hideTransactionDetail();
          loadTransactionList();
        } else {
          const err = await res.json();
          showStatus('é©³å›å¤±è´¥: ' + err.error, true);
        }
      } catch (err) {
        showStatus('ç½‘ç»œé”™è¯¯: ' + err.message, true);
      }
    }

    function hideTransactionDetail() {
      document.getElementById('transactionDetail').classList.add('hidden');
      document.getElementById('transactionList').classList.remove('hidden');
    }

    function switchTab(tab) {
      document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
      document.getElementById('tab-' + tab).classList.add('active');
      if (tab === 'transactions') {
        loadTransactionList();
      } else if (tab === 'users') {
        loadUserList();
      }
    }

    // ä¿å­˜ç§é’¥åˆ° Cookieï¼ˆæœ‰æ•ˆæœŸ 7 å¤©ï¼‰
    function savePrivateKeyToCookie() {
      const key = document.getElementById('privateKeyInput').value.trim();
      if (!key) {
        showStatus('ç§é’¥ä¸ºç©ºï¼Œæ— æ³•ä¿å­˜', true);
        return;
      }
      // è½¬ä¹‰æ¢è¡Œç¬¦å’Œç‰¹æ®Šå­—ç¬¦ï¼Œé¿å… Cookie è§£æé”™è¯¯
      const encoded = encodeURIComponent(key.replace(/\r\n/g, '\n')); // ç»Ÿä¸€ä¸º \n
      const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toUTCString(); // 7å¤©
      document.cookie = `adminPrivateKey=${encoded}; expires=${expires}; path=/; SameSite=Strict`;
      showStatus('âœ… ç§é’¥å·²ä¿å­˜åˆ°æœ¬åœ°ï¼ˆä»…æœ¬è®¾å¤‡ï¼‰');
    }

    // ä» Cookie è¯»å–ç§é’¥å¹¶å¡«å……
    function loadPrivateKeyFromCookie() {
      const name = 'adminPrivateKey=';
      const decodedCookie = decodeURIComponent(document.cookie);
      const ca = decodedCookie.split(';');
      for (let i = 0; i < ca.length; i++) {
        let c = ca[i].trim();
        if (c.indexOf(name) === 0) {
          const value = c.substring(name.length);
          // è¿˜åŸæ¢è¡Œç¬¦
          const restored = value.replace(/\n/g, '\r\n');
          document.getElementById('privateKeyInput').value = restored;
          return true;
        }
      }
      return false;
    }

    // æ¸…é™¤ Cookie
    function clearPrivateKeyCookie() {
      document.cookie = 'adminPrivateKey=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/';
      document.getElementById('privateKeyInput').value = '';
      showStatus('ğŸ—‘ï¸ æœ¬åœ°ç§é’¥å·²æ¸…é™¤');
    }

    document.addEventListener('DOMContentLoaded', () => {
      loadUserList();
      // ğŸ‘‡ æ–°å¢ï¼šè‡ªåŠ¨åŠ è½½ç§é’¥
      loadPrivateKeyFromCookie();
    });

    // ========== åˆå§‹åŒ– ==========
    document.addEventListener('DOMContentLoaded', () => {
      loadUserList();
    });

  </script>
</body>

</html>